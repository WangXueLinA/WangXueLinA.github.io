---
toc: content
title: Http
---

# HTTP

## 状态码

- **1XX**：信息响应类，表示接收的请求正在处理。
  - 100 Continue，表示请求继续。
- **2XX**：成功响应类，表示请求已成功被服务器接收、理解并接受。
  - 200 OK，表示请求成功完成。
  - 201 Created，表示请求已被 fulfilled，并且一个新资源已经按照请求的 URL 创建。
- **3XX**：重定向类，需要进一步操作以完成请求。
  - 301 Moved Permanently，永久重定向。
  - 302 Found，临时重定向。
- **4XX**：客户端错误，请求包含错误语法或者无法完成请求。
  - 400 Bad Request，表示请求报文存在语法错误。
  - 401 Unauthorized，表示未授权，需要用户身份验证。
  - 403 Forbidden，服务器理解请求但拒绝执行。
  - 404 Not Found，请求资源不存在。
- **5XX**：服务器错误，服务器在处理请求的过程中发生了错误。
  - 500 Internal Server Error，服务器遇到未知错误。
  - 502 Bad Gateway，作为网关或者代理工作的服务器，从上游服务器接收到无效的响应。
  - 503 Service Unavailable，服务器暂时无法处理请求，通常由于超载或维护。

## 从输入 url 到浏览器显示页面过程中都发生了什么

从在浏览器地址栏输入 URL 到页面最终显示，整个过程大致可以分为以下几个步骤：

1. **URL 解析与检查缓存：**

- 用户在浏览器地址栏输入 URL 后，浏览器首先解析该 URL，提取协议、域名、路径等信息。
- 浏览器检查本地缓存以及浏览器缓存中是否有该 URL 对应的页面资源。如果存在且未过期，浏览器可能直接使用缓存中的资源，跳过后续的网络请求步骤。

2. **DNS 解析：**

如果缓存中没有所需资源或资源已过期，浏览器会通过 DNS（域名系统）将 URL 中的域名解析为服务器的 IP 地址。这一过程可能包括查询操作系统缓存、本地 DNS 缓存、路由器缓存以及向 DNS 服务器发送查询请求。

3.  **建立 TCP 连接：**

解析到 IP 地址后，浏览器使用 TCP 协议与服务器建立连接。这通常涉及 TCP 三次握手过程，以确保数据传输的可靠性和顺序。

4. **发送 HTTP/HTTPS 请求：**

建立连接后，浏览器向服务器发送 HTTP 或 HTTPS 请求。请求中包含 URL、请求方法（通常是 GET）、浏览器信息、接受的数据类型等头部信息。

5. **服务器处理请求：**

服务器接收到请求后，根据请求内容处理请求。这可能涉及运行后端代码、查询数据库、生成动态内容等操作。

6. **服务器返回响应：**

处理完成后，服务器将响应数据（包括状态码、响应头和响应体）发送回浏览器。响应体可能包含 HTML、CSS、JavaScript 文件以及图片等静态资源。

7. **渲染页面：**

- 浏览器接收到响应后开始解析 HTML，构建 DOM（文档对象模型）树。同时，解析 CSS 构建 CSSOM（CSS 对象模型）树，并将两者合并生成渲染树。
- 浏览器计算渲染树的布局，确定每个节点的几何位置。
- 最后进行绘制，将渲染树的各个节点绘制到屏幕上。

8. **加载额外资源：**

- 在解析 HTML 过程中，浏览器遇到如 JS、CSS、图片等外部资源链接时，会发送额外的 HTTP 请求获取这些资源。
- JavaScript 可能会修改 DOM 和 CSSOM，导致重新布局和绘制，这一过程称为重绘或回流。

9. **执行 JavaScript：**

页面上的 JavaScript 会被下载并执行，可能用于实现交互功能、异步数据加载等。

10. **页面加载完成：**

- 完成加载：当初始 HTML 文档及所有引用的资源（如图片、脚本）都已加载完毕，浏览器触发 DOMContentLoaded 事件（DOM 解析完成）和 load 事件（页面完全加载完成）。
- 连接关闭：当浏览器不再需要与服务器通信时，TCP 连接通过“四次挥手”过程优雅关闭。

## http 跟 https 的区别

1. **安全性：**

- HTTP：不安全，因为它是以明文形式传输数据，容易被截取和篡改，不适合传输敏感信息。
- HTTPS：安全，它在 HTTP 的基础上加入了 SSL/TLS 协议，对传输的数据进行加密，可以有效防止数据在传输过程中被窃取或篡改，适合传输敏感信息，如银行账户、个人数据等。

2. **加密机制：**

- HTTP：不提供加密机制。
- HTTPS：使用 SSL/TLS 协议进行加密，确保数据的保密性和完整性。这一过程包括了数据的加密、解密，以及客户端和服务器的身份验证。

3. **端口：**

- HTTP：默认使用 80 端口。
- HTTPS：默认使用 443 端口。

4. **证书：**

- HTTP：不需要 SSL 证书。
- HTTPS：需要从受信任的证书颁发机构（CA）获得 SSL 证书，这通常需要购买，尽管也有一些免费的证书提供者。证书用于验证服务器的身份，增加用户信任度。

5. **性能：**

- HTTP：由于无需加密解密过程，理论上比 HTTPS 更快一些。
- HTTPS：由于涉及加密处理，可能会稍微影响页面加载速度，但随着技术的进步和硬件加速，这种影响越来越小，而且现代浏览器和服务器优化对此有所缓解。

6. **搜索引擎优化（SEO）：**

HTTPS：被搜索引擎视为更安全的信号，可能对搜索排名有利。

7. **现代 Web 标准：**

HTTPS：越来越多的 Web 技术和 API 要求或推荐使用 HTTPS，例如地理定位、Service Workers、Payment Request API 等。

## get 跟 post 传输方式区别

1. **数据传输位置：**

- GET：请求参数附加在 URL 之后，通过查询字符串（query string）传递，因此参数长度受限于 URL 长度的限制（通常不超过 2048 字符，并且会显示在浏览器地址栏和服务器日志中）。
- POST：请求参数放在 HTTP 请求正文中（request body），不显示在 URL 中，因此可以传输大量数据，并且不会在浏览器的历史记录中留下数据的痕迹。

2. **缓存：**

- GET：请求可以被浏览器缓存和存储在浏览历史中，也有可能被代理服务器缓存。
- POST：请求不会被缓存，每次都会向服务器发送请求。

3. **安全性：**

- GET：因为参数直接暴露在 URL 中，相对不安全，不适合传输敏感信息。
- POST：相对更安全，数据不在 URL 中显示，但需要注意，虽然 POST 本身不显示数据，但并不意味着它绝对安全，因为 HTTP 协议本身不加密，对于敏感信息，还需配合 HTTPS 使用。

4. **应用场景：**

- GET：通常用于获取资源，如查询数据库、检索信息等，适合幂等操作。
- POST：用于提交数据到服务器，如表单提交、上传文件、创建新资源等非幂等操作。

5. **浏览器限制：**

- GET：由于数据在 URL 中，可能会受到浏览器对 URL 长度的限制。
- POST：通常没有这样的长度限制，更适合传输大量数据。

## 本地存储四种方式

### Cookie

特点：

- 大小限制：通常限制在 4KB 左右，不同浏览器可能有所不同。
- 数据格式：以键值对的形式存储，且可以设置过期时间、路径、域和 httpOnly 属性。
- 生命周期：可以设置过期时间，或者在浏览器会话结束时失效（如果没有设置过期时间）。
- 与请求相关：随每次 HTTP 请求发送到服务器，可能导致不必要的网络流量。
- 作用域：可以在所有同源的窗口或文档中共享。

使用场景：适用于存储小型数据片段，如用户偏好设置、会话标识等，特别适用于需要在服务器和客户端之间共享数据的场景。

### Web Storage（Web 存储）

**localStorage：**

特点：

- 生命周期：没有过期时间，除非手动清除，否则数据会一直保存。
- 容量限制：相比 Cookie，Session Storage 提供了更大的存储空间，通常为 5MB 至 10MB。
- 安全性：虽然数据不发送到服务器，但仍可被客户端脚本访问，不适合存储高度敏感信息。
- 作用域：在所有同源的浏览器窗口和标签页中共享。

使用场景：适合长期存储客户端数据，比如用户设置、主题偏好等，不涉及服务器交互的场景。

**sessionStorage：**

特点：

- 生命周期：数据仅在当前浏览器会话期间有效，标签页或窗口关闭后数据消失。
- 容量限制：与 Session Storage 相似，提供较大存储空间，一般为 5MB 至 10MB。
- 安全性：因为数据不与服务器交互，且不跨窗口共享，所以在一定程度上减少了数据泄露的风险。
- 作用域：仅限于同一浏览器窗口或标签页，不同的窗口或标签页间不共享。

使用场景：适用于存储会话相关的临时数据，比如表单填写进度、用户登录状态（仅限于当前会话）。

### IndexedDB

特点：

- 容量大：可以存储大量结构化数据，适合复杂的数据存储需求。
- 异步 API：操作是异步的，不会阻塞 UI 线程。
- 支持事务：提供事务处理，可以实现数据的原子性、一致性、隔离性和持久性（ACID 特性）。

使用场景：适用于需要在客户端存储大量结构化数据的应用，如离线存储应用数据、缓存用户生成的内容等。

### 区别与选择

- 数据量与复杂性：Cookie 和 Web Storage 适用于较小、简单的数据存储，而 IndexedDB 适合处理大量、复杂的数据。
- 数据寿命：Cookie 和 sessionStorage 数据寿命较短或与会话相关，localStorage 数据长期保存，而 IndexedDB 数据持续存在直到被删除。
- 与服务器交互：Cookie 可以自动随请求发送到服务器，而其他存储方式需通过 JavaScript 手动操作。
- 安全性：httpOnly 标记可以增强 Cookie 的安全性，避免通过 JavaScript 访问；IndexedDB 和 Web Storage 的数据不能自动与服务器交互，但需要关注客户端脚本的安全问题。
