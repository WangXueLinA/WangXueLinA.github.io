---
toc: content
title: Http
---

# HTTP

## 状态码

- **1XX**：信息响应类，表示接收的请求正在处理。
  - 100 Continue，表示请求继续。
- **2XX**：成功响应类，表示请求已成功被服务器接收、理解并接受。
  - 200 OK，表示请求成功完成。
  - 201 Created，表示请求已被 fulfilled，并且一个新资源已经按照请求的 URL 创建。
- **3XX**：重定向类，需要进一步操作以完成请求。
  - 301 Moved Permanently，永久重定向。
  - 302 Found，临时重定向。
- **4XX**：客户端错误，请求包含错误语法或者无法完成请求。
  - 400 Bad Request，表示请求报文存在语法错误。
  - 401 Unauthorized，表示未授权，需要用户身份验证。
  - 403 Forbidden，服务器理解请求但拒绝执行。
  - 404 Not Found，请求资源不存在。
- **5XX**：服务器错误，服务器在处理请求的过程中发生了错误。
  - 500 Internal Server Error，服务器遇到未知错误。
  - 502 Bad Gateway，作为网关或者代理工作的服务器，从上游服务器接收到无效的响应。
  - 503 Service Unavailable，服务器暂时无法处理请求，通常由于超载或维护。

## 从输入 url 到浏览器显示页面过程中都发生了什么

从在浏览器地址栏输入 URL 到页面最终显示，整个过程大致可以分为以下几个步骤：

### **URL 解析与检查缓存：**

![](/images/http/image4.jpg)

- 用户在浏览器地址栏输入 URL 后，浏览器首先解析该 URL，提取协议、域名、路径等信息。

![](/images/http/image6.jpg)

- 浏览器检查本地缓存以及浏览器缓存中是否有该 URL 对应的页面资源。如果存在且未过期，浏览器可能直接使用缓存中的资源，跳过后续的网络请求步骤。

### **DNS 解析：**

![](/images/http/image7.jpg)

如果缓存中没有所需资源或资源已过期，浏览器会通过 DNS（域名系统）将 URL 中的域名解析为服务器的 IP 地址。这一过程可能包括查询操作系统缓存、本地 DNS 缓存、路由器缓存以及向 DNS 服务器发送查询请求。

### **建立 TCP 连接：**

![](/images/http/image5.jpg)

解析到 IP 地址后，浏览器使用 TCP 协议与服务器建立连接。这通常涉及 TCP 三次握手过程，以确保数据传输的可靠性和顺序。

### **发送 HTTP/HTTPS 请求：**

建立连接后，浏览器向服务器发送 HTTP 或 HTTPS 请求。请求中包含 URL、请求方法（通常是 GET）、浏览器信息、接受的数据类型等头部信息。

![](/images/http/image11.jpg)

### **服务器处理请求：**

服务器接收到请求后，根据请求内容处理请求。这可能涉及运行后端代码、查询数据库、生成动态内容等操作。

![](/images/http/image10.jpg)

### **服务器返回响应：**

处理完成后，服务器将响应数据（包括状态码、响应头和响应体）发送回浏览器。响应体可能包含 HTML、CSS、JavaScript 文件以及图片等静态资源。

![](/images/http/image12.jpg)

### **渲染页面：**

- 浏览器接收到响应后开始解析 HTML，构建 DOM（文档对象模型）树。同时，解析 CSS 构建 CSSOM（CSS 对象模型）树，并将两者合并生成渲染树。
- 浏览器计算渲染树的布局，确定每个节点的几何位置。
- 最后进行绘制，将渲染树的各个节点绘制到屏幕上。

![](/images/http/image8.jpg)

### **加载额外资源：**

- 在解析 HTML 过程中，浏览器遇到如 JS、CSS、图片等外部资源链接时，会发送额外的 HTTP 请求获取这些资源。
- JavaScript 可能会修改 DOM 和 CSSOM，导致重新布局和绘制，这一过程称为重绘或回流。

### **执行 JavaScript：**

页面上的 JavaScript 会被下载并执行，可能用于实现交互功能、异步数据加载等。

![](/images/http/image9.jpg)

### **页面加载完成：**

- 完成加载：当初始 HTML 文档及所有引用的资源（如图片、脚本）都已加载完毕，浏览器触发 DOMContentLoaded 事件（DOM 解析完成）和 load 事件（页面完全加载完成）。
- 连接关闭：当浏览器不再需要与服务器通信时，TCP 连接通过“四次挥手”过程优雅关闭。

## http 跟 https 的区别

1. **安全性：**

- HTTP：不安全，因为它是以明文形式传输数据，容易被截取和篡改，不适合传输敏感信息。
- HTTPS：安全，它在 HTTP 的基础上加入了 SSL/TLS 协议，对传输的数据进行加密，可以有效防止数据在传输过程中被窃取或篡改，适合传输敏感信息，如银行账户、个人数据等。

2. **加密机制：**

- HTTP：不提供加密机制。
- HTTPS：使用 SSL/TLS 协议进行加密，确保数据的保密性和完整性。这一过程包括了数据的加密、解密，以及客户端和服务器的身份验证。

3. **端口：**

- HTTP：默认使用 80 端口。
- HTTPS：默认使用 443 端口。

4. **证书：**

- HTTP：不需要 SSL 证书。
- HTTPS：需要从受信任的证书颁发机构（CA）获得 SSL 证书，这通常需要购买，尽管也有一些免费的证书提供者。证书用于验证服务器的身份，增加用户信任度。

5. **性能：**

- HTTP：由于无需加密解密过程，理论上比 HTTPS 更快一些。
- HTTPS：由于涉及加密处理，可能会稍微影响页面加载速度，但随着技术的进步和硬件加速，这种影响越来越小，而且现代浏览器和服务器优化对此有所缓解。

6. **搜索引擎优化（SEO）：**

HTTPS：被搜索引擎视为更安全的信号，可能对搜索排名有利。

7. **现代 Web 标准：**

HTTPS：越来越多的 Web 技术和 API 要求或推荐使用 HTTPS，例如地理定位、Service Workers、Payment Request API 等。

## get 跟 post 传输方式区别

1. **数据传输位置：**

- GET：请求参数附加在 URL 之后，通过查询字符串（query string）传递，因此参数长度受限于 URL 长度的限制（通常不超过 2048 字符，并且会显示在浏览器地址栏和服务器日志中）。
- POST：请求参数放在 HTTP 请求正文中（request body），不显示在 URL 中，因此可以传输大量数据，并且不会在浏览器的历史记录中留下数据的痕迹。

2. **缓存：**

- GET：请求可以被浏览器缓存和存储在浏览历史中，也有可能被代理服务器缓存。
- POST：请求不会被缓存，每次都会向服务器发送请求。

3. **安全性：**

- GET：因为参数直接暴露在 URL 中，相对不安全，不适合传输敏感信息。
- POST：相对更安全，数据不在 URL 中显示，但需要注意，虽然 POST 本身不显示数据，但并不意味着它绝对安全，因为 HTTP 协议本身不加密，对于敏感信息，还需配合 HTTPS 使用。

4. **应用场景：**

- GET：通常用于获取资源，如查询数据库、检索信息等，适合幂等操作。
- POST：用于提交数据到服务器，如表单提交、上传文件、创建新资源等非幂等操作。

5. **浏览器限制：**

- GET：由于数据在 URL 中，可能会受到浏览器对 URL 长度的限制。
- POST：通常没有这样的长度限制，更适合传输大量数据。

## 本地存储四种方式

### Cookie

特点：

- 大小限制：通常限制在 4KB 左右，不同浏览器可能有所不同。
- 数据格式：以键值对的形式存储，且可以设置过期时间、路径、域和 httpOnly 属性。
- 生命周期：可以设置过期时间，或者在浏览器会话结束时失效（如果没有设置过期时间）。
- 与请求相关：随每次 HTTP 请求发送到服务器，可能导致不必要的网络流量。
- 作用域：可以在所有同源的窗口或文档中共享。

使用场景：适用于存储小型数据片段，如用户偏好设置、会话标识等，特别适用于需要在服务器和客户端之间共享数据的场景。

### Web Storage（Web 存储）

**localStorage：**

特点：

- 生命周期：没有过期时间，除非手动清除，否则数据会一直保存。
- 容量限制：相比 Cookie，Session Storage 提供了更大的存储空间，通常为 5MB 至 10MB。
- 安全性：虽然数据不发送到服务器，但仍可被客户端脚本访问，不适合存储高度敏感信息。
- 作用域：在所有同源的浏览器窗口和标签页中共享。

使用场景：适合长期存储客户端数据，比如用户设置、主题偏好等，不涉及服务器交互的场景。

**sessionStorage：**

特点：

- 生命周期：数据仅在当前浏览器会话期间有效，标签页或窗口关闭后数据消失。
- 容量限制：与 Session Storage 相似，提供较大存储空间，一般为 5MB 至 10MB。
- 安全性：因为数据不与服务器交互，且不跨窗口共享，所以在一定程度上减少了数据泄露的风险。
- 作用域：仅限于同一浏览器窗口或标签页，不同的窗口或标签页间不共享。

使用场景：适用于存储会话相关的临时数据，比如表单填写进度、用户登录状态（仅限于当前会话）。

### IndexedDB

特点：

- 容量大：可以存储大量结构化数据，适合复杂的数据存储需求。
- 异步 API：操作是异步的，不会阻塞 UI 线程。
- 支持事务：提供事务处理，可以实现数据的原子性、一致性、隔离性和持久性（ACID 特性）。

使用场景：适用于需要在客户端存储大量结构化数据的应用，如离线存储应用数据、缓存用户生成的内容等。

### 区别与选择

- 数据量与复杂性：Cookie 和 Web Storage 适用于较小、简单的数据存储，而 IndexedDB 适合处理大量、复杂的数据。
- 数据寿命：Cookie 和 sessionStorage 数据寿命较短或与会话相关，localStorage 数据长期保存，而 IndexedDB 数据持续存在直到被删除。
- 与服务器交互：Cookie 可以自动随请求发送到服务器，而其他存储方式需通过 JavaScript 手动操作。
- 安全性：httpOnly 标记可以增强 Cookie 的安全性，避免通过 JavaScript 访问；IndexedDB 和 Web Storage 的数据不能自动与服务器交互，但需要关注客户端脚本的安全问题。

## TCP 三次握手和四次挥手

TCP 的三次握手和四次挥手实质就是 TCP 通信的连接和断开。

三次握手：为了对每次发送的数据量进行跟踪与协商，确保数据段的发送和接收同步，根据所接收到的数据量而确认数据发送、接收完毕后何时撤消联系，并建立虚连接。

四次挥手：即终止 TCP 连接，就是指断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开。

![](/images/http/image1.jpg)

### 三次握手

原理：​

- 第 1 次握手：客户端发送一个带有 SYN 报文的数据包给服务端（客户端发送网络包，服务端收到了这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的）；

- 第 2 次握手：服务端接收成功后，回传一个带有 SYN/ACK 报文的数据包传递确认信息，表示我收到了；（服务端发包，客户端收到了这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常）

- 第 3 次握手：客户端再回传一个带有 ACK 报文的数据包，表示我知道了，握手结束。（客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常）

通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了

![](/images/http/image2.jpg)

详细说明：

- 1、客户端发送建立 TCP 连接的请求报文，其中报文中包含 seq 序列号，是由发送端随机生成的，并且将报文中的 SYN 字段置为 1，表示需要建立 TCP 连接。（SYN=1，seq=x，x 为随机生成数值）；

- 2、服务端回复客户端发送的 TCP 连接请求报文，其中包含 seq 序列号，是由回复端随机生成的，并且将 SYN 置为 1，而且会产生 ACK 字段，ACK 字段数值是在客户端发送过来的序列号 seq 的基础上加 1 进行回复，以便客户端收到信息时，知晓自己的 TCP 建立请求已得到验证。（SYN=1，ACK=x+1，seq=y，y 为随机生成数值）这里的 ack 加 1 可以理解为是确认和谁建立连接；

- 3、客户端收到服务端发送的 TCP 建立验证请求后，会使自己的序列号加 1 表示，并且再次回复 ACK 验证请求，在服务端发过来的 seq 上加 1 进行回复。（SYN=1，ACK=y+1，seq=x+1）。

### 为什么不是两次握手？

如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到

并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源

### 四次挥手

由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭

原理：​

- 第 1 次挥手：客户端发送一个 FIN，用来关闭客户端到服务端的数据传送，客户端进入 FIN_WAIT_1 状态；

- 第 2 次挥手：服务端收到 FIN 后，发送一个 ACK 给客户端，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号），服务端进入 CLOSE_WAIT 状态；

- 第 3 次挥手：服务端发送一个 FIN，用来关闭服务端到客户端的数据传送，服务端进入 LAST_ACK 状态；

- 第 4 次挥手：客户端收到 FIN 后，客户端 t 进入 TIME_WAIT 状态，接着发送一个 ACK 给 Server，确认序号为收到序号+1，服务端进入 CLOSED 状态，完成四次挥手。

其中：FIN 标志位数置 1，表示断开 TCP 连接。

![](/images/http/image3.jpg)

详细说明：​

- 1、客户端发送断开 TCP 连接请求的报文，其中报文中包含 seq 序列号，是由发送端随机生成的，并且还将报文中的 FIN 字段置为 1，表示需要断开 TCP 连接。（FIN=1，seq=x，x 由客户端随机生成）；

- 2、服务端会回复客户端发送的 TCP 断开请求报文，其包含 seq 序列号，是由回复端随机生成的，而且会产生 ACK 字段，ACK 字段数值是在客户端发过来的 seq 序列号基础上加 1 进行回复，以便客户端收到信息时，知晓自己的 TCP 断开请求已经得到验证。（FIN=1，ACK=x+1，seq=y，y 由服务端随机生成）；

- 3、服务端在回复完客户端的 TCP 断开请求后，不会马上进行 TCP 连接的断开，服务端会先确保断开前，所有传输到 A 的数据是否已经传输完毕，一旦确认传输数据完毕，就会将回复报文的 FIN 字段置 1，并且产生随机 seq 序列号。（FIN=1，ACK=x+1，seq=z，z 由服务端随机生成）；

- 4、客户端收到服务端的 TCP 断开请求后，会回复服务端的断开请求，包含随机生成的 seq 字段和 ACK 字段，ACK 字段会在服务端的 TCP 断开请求的 seq 基础上加 1，从而完成服务端请求的验证回复。（FIN=1，ACK=z+1，seq=h，h 为客户端随机生成）

### 四次挥手原因

服务端在收到客户端断开连接 Fin 报文后，并不会立即关闭连接，而是先发送一个 ACK 包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送 FIN 报文断开连接，因此需要四次挥手
